【JVM】
JVM类加载机制分为五个部分：加载，验证，准备，解析，初始化

【集合】
|集合的底层原理|
# ArrayList #是List接口的可变数组非同步实现，并允许包括null在内的所有元素。
底层使用数组实现，该集合是可变长度数组，数组扩容时，会将老数组中的元素重新拷贝一份到新的数组中，每次数组容量增长大约是其容量的1.5倍，这种操作的代价很高。
采用了Fail-Fast机制，面对并发的修改时，迭代器很快就会完全失败，而不是冒着在将来某个不确定时间发生任意不确定行为的风险
remove方法会让下标到数组末尾的元素向前移动一个单位，并把最后一位的值置空，方便GC

# HashMap #是基于哈希表的Map接口的非同步实现，允许使用null值和null键，但不保证映射的顺序。
底层使用数组实现，数组中每一项是个单向链表，即数组和链表的结合体；当链表长度大于一定阈值时，链表转换为红黑树，这样减少链表查询时间。
HashMap在底层将key-value当成一个整体进行处理，这个整体就是一个Node对象。
HashMap底层采用一个Node[]数组来保存所有的key-value对，当需要存储一个Node对象时，会根据key的hash算法来决定其在数组中的存储位置，
在根据equals方法决定其在该数组位置上的链表中的存储位置；当需要取出一个Node时，也会根据key的hash算法找到其在数组中的存储位置，
再根据equals方法从该位置上的链表中取出该Node。HashMap进行数组扩容需要重新计算扩容后每个元素在数组中的位置，很耗性能
采用了Fail-Fast机制，通过一个modCount值记录修改次数，对HashMap内容的修改都将增加这个值。
迭代器初始化过程中会将这个值赋给迭代器的expectedModCount，在迭代过程中，判断modCount跟expectedModCount是否相等，
如果不相等就表示已经有其他线程修改了Map，马上抛出异常

# Hashtable #是基于哈希表的Map接口的同步实现，不允许使用null值和null键
底层使用数组实现，数组中每一项是个单链表，即数组和链表的结合体
Hashtable在底层将key-value当成一个整体进行处理，这个整体就是一个Entry对象。
Hashtable底层采用一个Entry[]数组来保存所有的key-value对，当需要存储一个Entry对象时，会根据key的hash算法来决定其在数组中的存储位置，
在根据equals方法决定其在该数组位置上的链表中的存储位置；当需要取出一个Entry时，也会根据key的hash算法找到其在数组中的存储位置，
再根据equals方法从该位置上的链表中取出该Entry。synchronized是针对整张Hash表的，即每次锁住整张表让线程独占

# ConcurrentHashMap #允许多个修改操作并发进行，其关键在于使用了锁分离技术。
它使用了多个锁来控制对hash表的不同段进行的修改，每个段其实就是一个小的hashtable，它们有自己的锁。
只要多个并发发生在不同的段上，它们就可以并发进行。
ConcurrentHashMap在底层将key-value当成一个整体进行处理，这个整体就是一个Entry对象。
Hashtable底层采用一个Entry[]数组来保存所有的key-value对，当需要存储一个Entry对象时，会根据key的hash算法来决定其在数组中的存储位置，
在根据equals方法决定其在该数组位置上的链表中的存储位置；当需要取出一个Entry时，也会根据key的hash算法找到其在数组中的存储位置，
再根据equals方法从该位置上的链表中取出该Entry。与HashMap不同的是，ConcurrentHashMap使用多个子Hash表，也就是段(Segment)
ConcurrentHashMap完全允许多个读操作并发进行，读操作并不需要加锁。如果使用传统的技术，如HashMap中的实现，
如果允许可以在hash链的中间添加或删除元素，读操作不加锁将得到不一致的数据。ConcurrentHashMap实现技术是保证HashEntry几乎是不可变的。